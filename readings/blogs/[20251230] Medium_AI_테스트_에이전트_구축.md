# 나만의 AI 테스트 에이전트 구축해보기

- **출처**: [Medium - 한정(Han Jung)](https://junghan92.medium.com/나만의-ai-테스트-에이전트-구축해보기-0d2c2beddb2b)
- **저자**: 한정(Han Jung)
- **게시일**: 2025-12-29 (1 day ago)
- **읽은 날짜**: 2025-12-30
- **태그**: #TDD #AIAgent #TestDrivenGeneration #ClaudeCode #SubAgent

## 핵심 내용

### 왜 TDD + AI인가?

**켄트 벡의 인사이트**:
> "TDD가 AI 에이전트와 함께 작업할 때 '슈퍼파워'다. AI 에이전트는 의도치 않게 코드를 망가뜨릴 수 있지만, 테스트를 통해 AI가 코드를 망가뜨리는 것을 잡아낼 수 있다."

> "자신의 기술 중 90%가 가치를 잃고, 10%의 가치가 1,000배 증가했다" - 마일스톤 관리, 복잡도 제어를 위한 설계 유지 등

**builder.io 관점**:
> "인간이 TDD를 힘들게 만드는 모든 것이 AI 에이전트에게는 완벽한 워크플로우가 된다"

### LLM 에이전트 정의 (회사별)

| 회사 | 정의 |
|------|------|
| **Anthropic** | LLM이 직접 흐름/도구 사용 여부를 결정하고 목표 달성 방법을 관리하는 시스템 |
| **OpenAI** | 루틴(Routine) = 명령(지시) + 도구 (시스템 프롬프트 + 도구) |
| **Google** | 세상을 관찰하고 도구들을 사용하여 목표를 달성하려는 애플리케이션 |
| **LangChain** | 작업 흐름을 선택할 때 LLM을 활용하는 시스템 |

### 에이전트 구성 요소

```
LLM 에이전트
├── 1. 계획 (Planning)
│   └── 복잡한 목표 → 작은 작업(Task)으로 분해
│
├── 2. 도구 사용 (Tool Use)
│   └── 파일 생성, 명령어 실행 등 실제 행동
│
├── 3. 피드백 순환 (Feedback Loop)
│   └── 결과 분석 → 에러 수정 → 반복
│
└── 4. 메모리 (Memory)
    ├── 단기 기억: 현재 대화/작업 컨텍스트
    └── 장기 기억: 과거 해결 경험 재사용
```

## Test Driven Generation 워크플로우

```
1. 명세 작성 ─────────────────────────────┐
   └─ 구체적인 기능 명세                    │
                                          │
2. 테스트 설계 ───────────────────────────┤
   └─ 켄트 벡처럼 생각하는 에이전트         │
                                          │
3. 테스트 작성 (RED) ─────────────────────┤
   └─ 실패하는 테스트 코드 생성             │
                                          │
4. 기능 개발 (GREEN) ─────────────────────┤
   └─ 테스트 통과하는 코드 작성             │
                                          │
5. 리팩토링 ──────────────────────────────┘
   └─ 코드 정리 및 개선
```

### 1단계: 명세 작성 팁

```markdown
✅ 반드시 프로젝트 분석 후 작업 범위 정리
✅ 모호하면 유저에게 질문 → 답변 받은 후 문서화
✅ 새로운 기능 추가 방지 (명세 구체화 정도로만)
✅ 체크리스트 활용
✅ 구체적인 입력값과 예시 결과값 제공
✅ 마크다운으로 작성, 계층화
✅ 생성된 문서 반드시 검토!
```

**핵심**: 이 명세 작성이 전체 워크플로우에서 **가장 중요**

### 2단계: 테스트 설계 팁

```markdown
✅ 기존 테스트 작성 방식 참고 (setupTest.ts 등)
✅ TDD 일환임을 명확히 인지시키기
✅ 테스트 설명은 최대한 구체적으로
✅ 명세 범위 벗어나지 않도록 제한
```

### 3단계: 테스트 작성 팁

```markdown
✅ 안티패턴, 라이브러리 철학 등 문서로 정리해 전달
✅ 기존 테스트 코드/유틸 함수 활용하도록 명시
```

### 4단계: 기능 개발 팁

```markdown
✅ 사용 가능한 API 명확히 알려주기
✅ 프로젝트 구조 파악 후 코드 작성 지시
✅ ⚠️ 테스트 절대 수정 금지 강조 (// DO NOT EDIT BY AI 주석)
✅ Context7 등 MCP 활용
✅ eslint/Prettier 규칙 준수
✅ 작은 이터레이션 반복
✅ 완료 후 코드 설명 요청
```

### 5단계: 리팩토링 팁

```markdown
✅ 프로젝트 구조 파악하고 기존 모듈/라이브러리 우선 사용
✅ 각 단계 끝나면 커밋 강제
```

## Claude Code Sub-Agent 활용

**특징**:
- **독립적인 컨텍스트 윈도우**: 메인 대화 오염 방지, 토큰 효율성 향상
- **전문화된 역할/도구 지정**: 특정 작업 최적화
- **재사용성**: 프로젝트/전역 수준에서 정의, 여러 프로젝트에서 재사용

## 인상 깊은 부분

> "AI 먼저가 아니라 프로세스 먼저. AI Agent는 이미 잘 작동하는 프로세스를 가속화하는 도구지, 존재하지 않는 프로세스를 대신 만들어주는 마법이 아니다."

> "AI의 과제 핵심은 'AI가 모든걸 잘 생성한다!'보다는 'AI가 사람이 하는것보다 비용 대비 잘 생성한다!' 관점"

> "에이전트에게 너무 많은 일을 한 번에 하도록 시키기보단 유저의 피드백을 명확하게 받고(HITL) 단계별로 작업을 진행하도록 하는 것이 좋다"

## 실무 적용 포인트

### 1. Human-in-the-loop (HITL) 필수
- 각 단계마다 검토 단계 포함
- 잘못된 방향으로 가면 디버깅 + 비용 증가

### 2. 명세가 가장 중요
- AI는 자기가 원하는대로 구현 방향 결정
- 구체적인 명세 → 원하는 방향 구현 확률 ↑
- 범위 넓고 클수록 결과 불만족 확률 ↑

### 3. 테스트 수정 방지
- `// DO NOT EDIT BY AI` 주석 활용
- 에이전트에 "절대 테스트 수정 금지" 강하게 명시

### 4. 비용 관리
- 잘못된 초기 방향 → 전체 재수정 → 비용 증가
- 초반에 인간 개입 많이 필요

### 5. 범용 vs 맞춤형
- 범용 에이전트 만들기 어려움
- **팀/개인에 맞는** 에이전트 구성이 효과적

## 주요 AI 개발 도구 (2025년 기준)

| 도구 | 특징 |
|------|------|
| **OpenAI Codex** | 클라우드 에이전트 + CLI, codex-1 모델 |
| **GitHub Copilot** | 다중 모델 지원, 에이전트 모드 |
| **Claude Code** | 깊은 코드베이스 이해, MCP 연결 |
| **Cline** | 오픈소스, Human-in-the-loop |
| **Cursor** | AI 네이티브 에디터, VS Code 기반 |
| **Windsurf** | 영구 무료, Cascade AI |
| **Gemini CLI** | 100만 토큰, Google Search 연동 |
| **Google Antigravity** | 에이전트 중심 플랫폼, 병렬 에이전트 관리 |

## 연관 글

- [컬리 OMS Claude AI 워크플로우](./[20251230]%20컬리_OMS_Claude_AI_워크플로우.md) - Role-Based AI 아키텍처 사례
- [Context Engineering 핵심역량](./[20251230]%20SKdevocean_Context_Engineering_핵심역량.md) - AI Context 설계

## 참고 자료

- [Test-driven development with AI - builder.io](https://www.builder.io/blog/tdd-ai)
- [Claude Code 마스터하기](https://revfactory.github.io/claude-code-mastering/)
- [GPT-5 프롬프트 가이드](https://platform.openai.com/docs/guides/prompt-engineering)
