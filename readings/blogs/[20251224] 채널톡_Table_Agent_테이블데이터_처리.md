# AI Agent가 복잡한 테이블 데이터 처리하는 방법

- **출처**: [채널톡 블로그](https://channel.io/ko/team/blog/articles/tech-table-ai-agent-e6b1056a)
- **저자**: Day, Machine Learning Engineer
- **읽은 날짜**: 2025-12-24
- **태그**: #RAG #Text-to-SQL #Agent #테이블처리 #ToolCalling

## 핵심 내용

### 문제: LLM이 테이블을 잘 못 이해함

**선형화(Linearization) 문제**
- 2차원 테이블 → 1차원 텍스트 변환 시 정보 손실
- 귀납 편향 파괴:
  - **근접성(Proximity)**: 가까운 토큰이 관련있다는 가정 위반
  - **인과성(Causality)**: 앞 토큰이 뒤에 영향 준다는 가정 위반

### 기존 접근법의 한계

| 방식 | 문제점 |
|------|--------|
| **RAG** | 각 행이 독립적 의미 단위가 아님, "제일 비싼 상품" 같은 절대적 비교 불가 |
| **Text-to-SQL** | "래쉬가드" vs "래시가드" 같은 표기 다양성 문제 |

## 해결: Table Agent (RAG + SQL 하이브리드)

### 핵심 아이디어

> "RAG의 벡터 검색 능력과 SQL의 필터링 능력을 혼합"

### 데이터 전처리 파이프라인

1. **열 분류**: LLM으로 "언어적 의미" 있는 열만 선별
   - 예: 상품명(O), 가격(X), 재고수량(X)

2. **셀 단위 청킹**: 중복 제거 후 벡터화
   - 결과: 전체 셀의 **1~2%만 벡터화** (효율적!)

### 에이전트 구조 진화

```
[초기 버전]
벡터 검색 → SQL (고정 순서)

[개선 버전]
LLM Tool Calling으로 유연한 루프
→ 상황에 맞게 검색/SQL 반복 호출
```

### 추가 기능
- "함수를 만드는 함수": 후처리 코드 생성 기능

## 성능 최적화 기법

### 1. ReAct 프롬프팅
- 도구 호출 전후로 현재 상황 정리 + 앞으로 할 일 메모하도록 유도

### 2. 남은 턴 수 공개
```
"현재 남은 도구 호출 기회: 3회"
```
→ 에이전트가 더 신중하게 의사결정

### 3. 에러 핸들링
- SQL 에러 발생 → 루프 지속 + 에러 로그 공개
- 결과 행 초과 → 경고로 추가 필터링 유도

## 인상 깊은 부분

> "셀 단위로 중복 제거 후 벡터화해서 전체 셀의 1~2%만 처리"

대규모 테이블도 효율적으로 처리 가능한 스케일링 전략

> "남은 턴 수를 프롬프트에 명시"

간단하지만 효과적인 에이전트 의사결정 품질 향상 방법

## 실무 적용 포인트

1. **하이브리드 접근법**
   - 단일 기술(RAG만 or SQL만)보다 조합이 효과적
   - 각 방식의 강점을 상호 보완

2. **효율적인 벡터화 전략**
   - 모든 데이터를 벡터화할 필요 없음
   - "언어적 의미" 있는 열만 선별 + 중복 제거

3. **에이전트 컨텍스트 설계**
   - 남은 리소스(턴 수, 토큰 등) 명시가 의사결정에 도움
   - 에러 정보 투명하게 공개 → 자가 수정 유도

4. **유연한 루프 구조**
   - 고정 파이프라인보다 Tool Calling 기반 유연한 구조
   - 다양한 쿼리 유형에 대응 가능

5. **ReAct 패턴 활용**
   - 도구 호출 전후 "생각" 단계 추가로 품질 향상
